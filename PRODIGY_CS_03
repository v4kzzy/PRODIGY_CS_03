import customtkinter as ctk
import re
import math
import string

# --- CONFIGURATION ---
ctk.set_appearance_mode("Dark")
ctk.set_default_color_theme("blue")

class PasswordLogic:
    """Handles the mathematics of password strength."""
    
    def calculate_entropy(self, password):
        if not password:
            return 0, 0
            
        # 1. Determine the 'Pool Size' (R)
        pool_size = 0
        if re.search(r'[a-z]', password): pool_size += 26
        if re.search(r'[A-Z]', password): pool_size += 26
        if re.search(r'[0-9]', password): pool_size += 10
        if re.search(r'[^a-zA-Z0-9]', password): pool_size += 32
        
        # 2. Calculate Entropy: E = L * log2(R)
        # Handle edge case where pool_size might be 0 (though regex prevents this mostly)
        if pool_size == 0:
            return 0, 0
            
        entropy = len(password) * math.log2(pool_size)
        return entropy, pool_size

    def estimate_crack_time(self, entropy):
        # Assume a powerful Cracking Rig doing 100 Billion guesses per second (10^11)
        guesses_per_second = 100_000_000_000
        total_combinations = 2 ** entropy
        seconds = total_combinations / guesses_per_second
        
        if seconds < 1: return "Instantly"
        if seconds < 60: return "A few seconds"
        if seconds < 3600: return f"{seconds/60:.0f} minutes"
        if seconds < 86400: return f"{seconds/3600:.0f} hours"
        if seconds < 31536000: return f"{seconds/86400:.0f} days"
        if seconds < 31536000 * 100: return f"{seconds/31536000:.0f} years"
        return "Centuries"

    def check_criteria(self, password):
        return {
            "length": len(password) >= 12,
            "upper": bool(re.search(r'[A-Z]', password)),
            "lower": bool(re.search(r'[a-z]', password)),
            "digit": bool(re.search(r'[0-9]', password)),
            "special": bool(re.search(r'[^a-zA-Z0-9]', password))
        }

class FortressApp(ctk.CTk):
    def __init__(self):
        super().__init__()
        self.logic = PasswordLogic()

        # Window Setup
        self.title("Fortress // Password Auditor")
        self.geometry("500x600")
        self.grid_columnconfigure(0, weight=1)

        # --- HEADER ---
        self.lbl_title = ctk.CTkLabel(self, text="FORTRESS AUDIT", font=ctk.CTkFont(size=24, weight="bold"))
        self.lbl_title.pack(pady=(30, 10))

        # --- INPUT AREA ---
        self.input_frame = ctk.CTkFrame(self, fg_color="transparent")
        self.input_frame.pack(pady=10, padx=20, fill="x")

        self.entry_pass = ctk.CTkEntry(self.input_frame, placeholder_text="Type password to audit...", width=300, show="‚Ä¢", font=ctk.CTkFont(size=16))
        self.entry_pass.pack(side="left", fill="x", expand=True, padx=(0, 10))
        # Bind key release to update function
        self.entry_pass.bind("<KeyRelease>", self.update_analysis)

        self.btn_show = ctk.CTkButton(self.input_frame, text="üëÅ", width=40, command=self.toggle_visibility)
        self.btn_show.pack(side="right")
        self.is_visible = False

        # --- VISUAL METER ---
        self.progress = ctk.CTkProgressBar(self, height=15)
        self.progress.set(0)
        self.progress.pack(pady=20, padx=40, fill="x")

        self.lbl_strength = ctk.CTkLabel(self, text="Strength: Empty", font=ctk.CTkFont(size=18, weight="bold"))
        self.lbl_strength.pack()

        self.lbl_crack_time = ctk.CTkLabel(self, text="Time to crack: N/A", text_color="gray")
        self.lbl_crack_time.pack(pady=(0, 20))

        # --- CRITERIA LIST ---
        self.criteria_frame = ctk.CTkFrame(self)
        self.criteria_frame.pack(pady=10, padx=40, fill="both", expand=True)

        self.checks = {}
        labels = {
            "length": "At least 12 Characters",
            "upper": "Uppercase Letters (A-Z)",
            "lower": "Lowercase Letters (a-z)",
            "digit": "Numbers (0-9)",
            "special": "Special Symbols (!@#$)"
        }

        for key, text in labels.items():
            # Using Checkboxes as read-only indicators
            cb = ctk.CTkCheckBox(self.criteria_frame, text=text, state="disabled")
            cb.pack(pady=8, padx=20, anchor="w")
            self.checks[key] = cb

        # --- STATS BOX ---
        self.lbl_bits = ctk.CTkLabel(self, text="Entropy: 0 bits", font=ctk.CTkFont(family="Consolas"))
        self.lbl_bits.pack(pady=10)

    def toggle_visibility(self):
        if self.is_visible:
            self.entry_pass.configure(show="‚Ä¢")
            self.is_visible = False
        else:
            self.entry_pass.configure(show="")
            self.is_visible = True

    def update_analysis(self, event=None):
        password = self.entry_pass.get()
        entropy, pool = self.logic.calculate_entropy(password)
        criteria = self.logic.check_criteria(password)
        crack_time = self.logic.estimate_crack_time(entropy)

        # 1. Update Progress Bar & Color
        # Max reasonable entropy for a human password is ~128 bits
        progress_val = min(entropy / 100, 1.0)
        self.progress.set(progress_val)

        if entropy < 40:
            self.progress.configure(progress_color="#E74C3C") # Red
            strength_text = "WEAK"
        elif entropy < 60:
            self.progress.configure(progress_color="#F1C40F") # Yellow
            strength_text = "MODERATE"
        elif entropy < 80:
            self.progress.configure(progress_color="#3498DB") # Blue
            strength_text = "STRONG"
        else:
            self.progress.configure(progress_color="#2ECC71") # Green
            strength_text = "EXCELLENT"

        if len(password) == 0: strength_text = "Empty"

        # 2. Update Text Labels
        self.lbl_strength.configure(text=f"Strength: {strength_text}")
        self.lbl_crack_time.configure(text=f"Est. Crack Time (GPU Rig): {crack_time}")
        self.lbl_bits.configure(text=f"Entropy: {entropy:.1f} bits")

        # 3. Update Checkboxes
        for key, is_met in criteria.items():
            if is_met:
                self.checks[key].select()
            else:
                self.checks[key].deselect()

if __name__ == "__main__":
    app = FortressApp()
    app.mainloop()
